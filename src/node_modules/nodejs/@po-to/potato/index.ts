import * as url from 'url';
import * as http from 'http';
import cookie = require('cookie');
import queryString = require("querystring");
import fs = require('fs');
import request = require('request');
import path = require('path');

export interface IViews {
    getView(con: string): string | null;
    hasView(con: string): boolean;
}

export interface IControllers {
    getController(con: string): Controller | null;
    hasController(con: string): boolean;
}
export const IViewRendererDataNamespace: string = "com.potato.dev.IViewRendererData"

export class View {
    constructor(public readonly path: string) {

    }
}


export class ViewRendererData {
    public readonly type: string = IViewRendererDataNamespace;

    constructor(public readonly template: string | View, public readonly data: any = '', public readonly renderer: string = 'renderer') {

    }

}

export class Core {
    protected readonly _views: IViews;
    protected readonly _controllers: IControllers;
    protected readonly _rendererManager: { [key: string]: (template: string, data: any) => string };
    public readonly requestArgName: string = "__request__";
    public readonly requestAmdName: string = "amd";


    executeRequest(request: Request, resolve: (data: Object | ViewRendererData) => void, reject: (error: PError) => void): void {
        //console.log(request.controller, request.action);
        let isPublic = request.isRoot();
        let obj = this.getAction(request.controller, request.action, isPublic);
        if (obj) {
            request.beCache = obj.controller.__beCache(request);
            if (!isPublic || this.checkPermission(request)) {
                obj.controller[obj.action](request, resolve, reject);
            } else {
                reject(new PError('403'));
            }
        } else {
            reject(new PError('404'));
        }
    }
    routing(str: string, method: string, data?: any): {controller:string, action:string, path:string, args:any} | null {
        let urlData = url.parse(str, true);
        let pathname = urlData.pathname || '';
        let query = urlData.query;
        if (pathname) {
            if (pathname.endsWith('/')) {
                pathname = pathname.substr(0, pathname.length - 1);
            }
            if (pathname.startsWith('/')) {
                pathname = pathname.substr(1);
            }
        }
        let controller: string = '';
        let hasController: boolean = false;
        if (pathname) {
            let id: string | undefined;
            let path: string = '';
            let action: string = '';
            controller = pathname;
            hasController = this.hasController(controller, true);
            if (!hasController) {
                controller = pathname + '/Index';
                hasController = this.hasController(controller, true);
            }
            if (!hasController) {
                let arr = pathname.split('/');
                id = arr.pop();
                controller = arr.join("/");
                hasController = this.hasController(controller, true);
            }
            if (hasController) {
                switch (method) {
                    case "GET":
                        if (id === undefined && this.hasAction(controller, "Index", true)) {
                            path = "";
                            action = "Index";
                        } else {
                            path = id || "";
                            action = "Item";
                        }
                        break;
                }
                if (this.hasAction(controller, action, true)) {
                    return {controller:controller, action:action, path:path, args:Object.assign(query,data)};
                }
            }
        }
        return null;
    }
    loadUrl(url: string): Promise<any> | any {
        return '111';
    }
    checkPermission(request: Request): boolean {
        return true;
    }
    private _parseRendererData(data: ViewRendererData, toAmd: boolean): { deps: string[], callback: Function, atta: any[] } {
        let atta: any[] = [];
        let attaIndex = 0;
        let str = JSON.stringify(data, (key, value) => {
            if (value instanceof Request) {
                if (toAmd) {
                    let tempUrl = this.toUrl(value);
                    return 'import!' + tempUrl + (tempUrl.indexOf("?")>-1?"&":"?")+this.requestArgName+"="+this.requestAmdName;
                } else {
                    atta.push(value);
                    return 'import!req://' + attaIndex++;
                }
            } else if (value instanceof View) {
                if (toAmd) {
                    return 'import!' + this.toUrl(value);
                } else {
                    return 'import!view://' + value.path;
                }
            } else {
                return value;
            }
        });
        let deps = {}, i = 0;
        let args0: string[] = ['rendererManager'], args1: string[] = ['rendererManager'];
        str = str.replace(/"import!(.+?)"/g, function ($0, $1) {
            if (!deps[$1]) {
                deps[$1] = "$" + i;
                i++;
            }
            return deps[$1];
        });
        for (let url in deps) {
            if (deps.hasOwnProperty(url)) {
                args0.push(url);
                args1.push(deps[url]);
            }
        }
        let fbody = `
            var result = ${str};
            return rendererManager.__parse__(result,"${IViewRendererDataNamespace}");
        `;
        args1.push(fbody);
        return { deps: args0, callback: new Function(...args1), atta: atta };
    }
    render(data: ViewRendererData, toAmd: boolean, success: (str: string) => void, failure?: (error: PError) => void) {
        if (!this._rendererManager['__parse__']) {
            this._rendererManager['__parse__'] = function (result: any, namespace: string) {
                for (let i in result.data) {
                    if (result.hasOwnProperty(i) && result[i] && result[i].type == namespace) {
                        result[i] = this.__parse__(result[i]);
                    }
                }
                return this[result.renderer](result.template, result.data);
            }
        }
        let {deps, callback, atta} = this._parseRendererData(data, toAmd);
        if (toAmd) {
            if (deps.length) {
                success('define(["' + deps.join('","') + '"],' + callback.toString() + ');');
            } else {
                success('define(' + callback.toString() + ');');
            }
        } else {
            let fun = (deps: string[], callback: Function) => {
                let depsValue = deps.map((url) => {
                    if (url == 'rendererManager') {
                        return this._rendererManager;
                    } else if (url.startsWith("view://")) {
                        return this._views.getView(url) || url + ' not found!';
                    } else if (url.startsWith("req://")) {
                        let index = parseInt(url.substr("req://".length));
                        let req: Request = atta[index];
                        return new Promise((resolve: (data: Object | ViewRendererData) => void, reject: (error: PError) => void) => {
                            this.executeRequest(req, (data: Object | ViewRendererData) => {
                                if (data instanceof ViewRendererData) {
                                    this.render(data, toAmd, resolve, reject);
                                } else {
                                    resolve(data);
                                }
                            }, reject);
                        });
                    } else {
                        return this.loadUrl(url);
                    }
                })
                Promise.all(depsValue).then(function (values: any[]) {
                    success(callback(...values));
                }).catch(function (error) {
                    failure && failure(error);
                })
            }
            fun(deps, callback);
        }
    }
    getController(path: string, isPublic: boolean): Controller | null {
        if (path) {
            let arr = path.split("/");
            let conName = arr[arr.length - 1];
            arr[arr.length - 1] = "_" + conName;
            let path2 = arr.join("/");
            if (isPublic) {
                if (conName.startsWith("_")) {
                    return null;
                } else {
                    return this._controllers.getController(path);
                }
            } else {
                return this._controllers.getController(path) || this._controllers.getController(path2);
            }
        } else {
            return null;
        }
    }
    hasController(path: string, isPublic: boolean): boolean {
        //console.log(path);
        return !!this.getController(path, isPublic);
    }
    hasAction(controller: string, action: string, isPublic: boolean): boolean {
        return !!this.getAction(controller, action, isPublic);
    }
    getAction(controller: string, action: string, isPublic: boolean): { controller: Controller, action: string } | null {
        let obj = this.getController(controller, isPublic);
        if (!obj) { return null };
        if (isPublic) {
            if (action.startsWith("_") || typeof (obj[action]) != "function") {
                return null;
            }
        } else {
            if (typeof (obj[action]) != "function") {
                action = '_' + action;
            }
            if (typeof (obj[action]) != "function") {
                return null;
            }
        }
        return { controller: obj, action: action };
    }
    entrance(req: http.IncomingMessage, res: http.ServerResponse, next: (error?: PError) => void) {
        let data = this.routing(req.url||'', req.method||'', {});
        if(data){
            let {controller,action,path,args} = data;
            let request = new RootRequest(controller, action, path, args, this, req, res);
            let isAmd = args && args[this.requestArgName] == this.requestAmdName;
            this.executeRequest(request, (data) => {
                res.setHeader('Content-Type',isAmd?'application/javascript':'text/html; charset=utf-8');
                if (data instanceof ViewRendererData) {
                    this.render(data, isAmd, function (str) {
                        //(res as any).cookie('uname','aaaaa');
                        res.end((request as RootRequest).setResponse(str));
                    }, function (error: PError) {
                        next(error);
                    });
                } else {
                    res.end((request as RootRequest).setResponse(data.toString()));
                }
            }, (error) => {
                next(error);
            })
        }else{
             next();
        }
    }
    toUrl(request: Request | View,method:string='GET'): string {
        if (request instanceof View) {
            return request.path + ".js";
        } else {
            let pathStr:string;
            if(request.url){
                pathStr = request.url;
            }else{
                pathStr = request.controller;
                if (request.path) {
                    pathStr += '/' + request.path;
                }
                pathStr += "/";
                switch (request.action) {
                    case "Index":
                        break;
                    case "Item":
                        break;
                }
            }
            
            // if (request.isViewRequest()) {
            //     let obj = {};
            //     obj[this.pageArgName] = "";
            //     obj[this.requestArgName] = this.requestAmdName;
            //     args = Object.assign({}, (noArgs ? {} : request.args), obj)
            // }
            return url.format({ pathname: pathStr, query: request.args });
        }
    }

}

export interface IRequest {
    beCache:boolean;
    readonly controller: string;
    readonly action: string;
    readonly path?: string;
    readonly args?:{ [key: string]: any };
}

export class Request implements IRequest {
    beCache:boolean;
    public args:{ [key: string]: any }|undefined;
    constructor(public readonly root: RootRequest, public readonly controller: string, public readonly action: string, public readonly path?: string, args?: any, public url?:string) {
        if (!args || !Object.keys(args).length) {
            this.args = undefined;
        }else{
            this.args = args;
        }
    }
    createViewRenderData(data?: { [key: string]: any }): { [key: string]: any } {
        return Object.assign({
            VPID: this.root.core.toUrl(this)
        }, data);
    }
    isRoot(): boolean {
        return this.root == (this as any);
    }
    toUrl(method:string='GET'): string {
        return this.root.core.toUrl(this,method);
    }
    getAction() {
        return this.root.core.getAction(this.controller, this.action, this.isRoot());
    }
    // isViewRequest(): boolean {
    //     let con = this.root.core.getController(this.controller, this.isRoot());
    //     return !!(con && con instanceof ViewController);
    // }
}
let rootRequest: RootRequest;
export class RootRequest extends Request {
    constructor(controller: string, action: string, path: string, args: any, public readonly core: Core, public readonly request: http.IncomingMessage, public readonly response: http.ServerResponse, url?:string) {
        super(rootRequest, controller, action, path, args, url);
        (this as any).root = this;
    }
    setResponse(data:string):string{
        if(this.beCache){
            // let dir = path.join(process.cwd(), 'caches/');
            // if (!fs.existsSync(dir)) {
            //     fs.mkdirSync(dir);
            // }
            // fs.writeFile(path.join()+".js", data);

            // console.log(this.toUrl(),data);
        }
        return data;
    }
    setCookie(name: string, val?: string, options?): void {
        //var signed = 's:' + signature.sign(val, secret);
        let data
        if (val === undefined) {
            data = name;
        } else {
            options = options || { path: "/", domain: "" };
            data = cookie.serialize(name, val, options);
        }
        let prev: any = this.response.getHeader('set-cookie') || [];
        var header = Array.isArray(prev) ? prev.concat(data)
            : Array.isArray(data) ? [prev].concat(data)
                : [prev, data];
        this.response.setHeader('set-cookie', header)
    }
    assignCookie(key:string, val:string){
        this.request['cookies'][key] = val;
    }
    getCookie(): null | { [key: string]: any } {
        return this.request['cookies'];
    }
    getIP(): string {
        let req = this.request;
        return req.headers['x-forwarded-for'] || req.connection.remoteAddress || req.socket.remoteAddress || '0.0.0.0';
    }
}




export class PError {
    constructor(public readonly eid: string, public readonly info?: any) {

    }
}
export class Model {
};
export class Controller {
     __beCache(request:Request):boolean{
        return false;
    }
};

export class ApiRequest {
    constructor(public readonly context: RootRequest, public url: string, public method?: string, public data?: { [key: string]: any } | string, public headers?: { [key: string]: string }, public render?: (data: any) => any) {

    }
}

export function callApi<T>(requestOptions: ApiRequest, succss?: (data: T) => void, fail?: (error: PError) => void): Promise<T> {
    return new Promise(function (resolve, reject) {
        let method: string = requestOptions.method || "GET";
        let url = requestOptions.url;
        let form: any;
        if (requestOptions.data && method == "GET") {
            url += (url.indexOf("?") > -1 ? '&' : '?') + (typeof (requestOptions.data) == "string" ? requestOptions.data : queryString.stringify(requestOptions.data));
        } else {
            form = requestOptions.data || null;
        }
        let arr = url.match(/\/\/(.+?)\//);
        let hostname = arr ? arr[1] : "";
        let cookies = requestOptions.context.getCookie();
        let headers = Object.assign({}, requestOptions.headers);
        if (cookies) {
            let cookiesArr: string[] = [];
            for (let key in cookies) {
                let site = key.substr(0, key.indexOf("$"));
                if (site && hostname.indexOf(site) > -1) {
                    let item = cookie.serialize(key.substr(key.indexOf("$") + 1), cookies[key]);
                    cookiesArr.push(item);
                }
            }
            if (cookiesArr.length) {
                if (headers["Cookie"]) {
                    cookiesArr.push(headers["Cookie"]);
                }
                headers["Cookie"] = cookiesArr.join("; ");
            }
        }
        let returnResult = function (data) {
            let result = requestOptions.render ? requestOptions.render(data) : data;
            if (result instanceof PError) {
                fail && fail(result);
                reject(result);
            } else {
                succss && succss(result);
                resolve(result);
            }
        }
        let stime = Date.now();
        request({ url: url, method: method, headers: headers, form: form }, function (error, response, body) {
            let consume = (Date.now() - stime) / 1000;
            let date =new Date();
            let mon = date.getMonth()+1;
            let day = date.getDate(); 
            let dateFormat = mon+'-'+day;
            let time = date.toLocaleString();
            let filename = method + "_" + url.replace(hostname, "").replace(/\W/g, '_');
            let dir = path.join(process.cwd(), 'logs/' + hostname +'-'+ dateFormat + '/');
            if (!fs.existsSync(dir)) {
                fs.mkdirSync(dir);
            }
             var requestInfo = {
                date: time,
                requestTime: consume,
                requestArgs: JSON.stringify(form),
                responseInfo: JSON.stringify(response),
                cookies: headers["Cookie"] || '',
            }
            fs.writeFile((dir + filename).substr(0, 200) + ".json", JSON.stringify(requestInfo)+'\n', {flag:'a'});
            if (response && !error && response.statusCode == 200) {
                let arr: string[] | null = response.headers['set-cookie'];
                if (arr) {
                    arr.forEach(function (cookie) {
                        if (/(^.*)(domain=)(.*)(; .*$)/.test(cookie)) {
                            cookie = cookie.replace(/(^.*)(domain=)(.*)(; .*$)/, function ($0, $1, $2, $3, $4) { return $3 + "$" + $1 + $2 + $4; });
                        } else {
                            cookie = response['request'].uri.hostname + "$" + cookie;
                        }
                        requestOptions.context.setCookie(cookie);
                    })
                }
                returnResult(body);
                // body = JSON.parse(body);
                // body.succ = parseInt(body.succ);
                // if (body.succ) {
                //     returnResult(body);
                // } else {
                //     returnResult(new PError("error"));
                // }
            } else {
                returnResult(error || new PError((response?response.statusCode:403) + ""));
            }
        });
    }).catch(function () {

    });
}